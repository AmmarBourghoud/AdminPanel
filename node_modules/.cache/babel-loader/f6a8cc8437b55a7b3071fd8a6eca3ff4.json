{"ast":null,"code":"import { mix } from \"./mix\";\nimport conf from \"./config\";\nimport _perfs from \"./perfs\";\nimport { middlewareHelper } from \"./middleware\";\nexport var resolver = function resolver(wretcher) {\n  var url = wretcher._url,\n      _catchers = wretcher._catchers,\n      resolvers = wretcher._resolvers,\n      middlewares = wretcher._middlewares,\n      opts = wretcher._options;\n  var catchers = new Map(_catchers);\n  var finalOptions = mix(conf.defaults, opts);\n  var fetchController = conf.polyfill(\"AbortController\", {\n    doThrow: false,\n    instance: true\n  });\n\n  if (!finalOptions[\"signal\"] && fetchController) {\n    finalOptions[\"signal\"] = fetchController.signal;\n  } // Request timeout\n\n\n  var timeout = {\n    ref: null,\n    clear: function clear() {\n      if (timeout.ref) {\n        clearTimeout(timeout.ref);\n        timeout.ref = null;\n      }\n    }\n  }; // The generated fetch request\n\n  var fetchRequest = middlewareHelper(middlewares)(conf.polyfill(\"fetch\"))(url, finalOptions); // Throws on an http error\n\n  var throwingPromise = fetchRequest.then(function (response) {\n    timeout.clear();\n\n    if (!response.ok) {\n      return response[conf.errorType || \"text\"]().then(function (msg) {\n        // Enhances the error object\n        var err = new Error(msg);\n        err[conf.errorType || \"text\"] = msg;\n        err[\"status\"] = response.status;\n        err[\"response\"] = response;\n        throw err;\n      });\n    }\n\n    return response;\n  }); // Wraps the Promise in order to dispatch the error to a matching catcher\n\n  var catchersWrapper = function catchersWrapper(promise) {\n    return promise.catch(function (err) {\n      timeout.clear();\n      if (catchers.has(err.status)) return catchers.get(err.status)(err, wretcher);else if (catchers.has(err.name)) return catchers.get(err.name)(err, wretcher);else throw err;\n    });\n  };\n\n  var bodyParser = function bodyParser(funName) {\n    return function (cb) {\n      return funName ? // If a callback is provided, then callback with the body result otherwise return the parsed body itself.\n      catchersWrapper(throwingPromise.then(function (_) {\n        return _ && _[funName]();\n      }).then(function (_) {\n        return _ && cb && cb(_) || _;\n      })) : // No body parsing method - return the response\n      catchersWrapper(throwingPromise.then(function (_) {\n        return _ && cb && cb(_) || _;\n      }));\n    };\n  };\n\n  var responseChain = {\n    /**\n     * Retrieves the raw result as a promise.\n     */\n    res: bodyParser(null),\n\n    /**\n     * Retrieves the result as a parsed JSON object.\n     */\n    json: bodyParser(\"json\"),\n\n    /**\n     * Retrieves the result as a Blob object.\n     */\n    blob: bodyParser(\"blob\"),\n\n    /**\n     * Retrieves the result as a FormData object.\n     */\n    formData: bodyParser(\"formData\"),\n\n    /**\n     * Retrieves the result as an ArrayBuffer object.\n     */\n    arrayBuffer: bodyParser(\"arrayBuffer\"),\n\n    /**\n     * Retrieves the result as a string.\n     */\n    text: bodyParser(\"text\"),\n\n    /**\n     * Performs a callback on the API performance timings of the request.\n     *\n     * Warning: Still experimental on browsers and node.js\n     */\n    perfs: function perfs(cb) {\n      fetchRequest.then(function (res) {\n        return _perfs.observe(res.url, cb);\n      });\n      return responseChain;\n    },\n\n    /**\n     * Aborts the request after a fixed time.\n     *\n     * @param time Time in milliseconds\n     * @param controller A custom controller\n     */\n    setTimeout: function (_setTimeout) {\n      function setTimeout(_x, _x2) {\n        return _setTimeout.apply(this, arguments);\n      }\n\n      setTimeout.toString = function () {\n        return _setTimeout.toString();\n      };\n\n      return setTimeout;\n    }(function (time, controller) {\n      if (controller === void 0) {\n        controller = fetchController;\n      }\n\n      timeout.clear();\n      timeout.ref = setTimeout(function () {\n        return controller.abort();\n      }, time);\n      return responseChain;\n    }),\n\n    /**\n     * Returns the automatically generated AbortController alongside the current wretch response as a pair.\n     */\n    controller: function controller() {\n      return [fetchController, responseChain];\n    },\n\n    /**\n     * Catches an http response with a specific error code or name and performs a callback.\n     */\n    error: function error(errorId, cb) {\n      catchers.set(errorId, cb);\n      return responseChain;\n    },\n\n    /**\n     * Catches a bad request (http code 400) and performs a callback.\n     */\n    badRequest: function badRequest(cb) {\n      return responseChain.error(400, cb);\n    },\n\n    /**\n     * Catches an unauthorized request (http code 401) and performs a callback.\n     */\n    unauthorized: function unauthorized(cb) {\n      return responseChain.error(401, cb);\n    },\n\n    /**\n     * Catches a forbidden request (http code 403) and performs a callback.\n     */\n    forbidden: function forbidden(cb) {\n      return responseChain.error(403, cb);\n    },\n\n    /**\n     * Catches a \"not found\" request (http code 404) and performs a callback.\n     */\n    notFound: function notFound(cb) {\n      return responseChain.error(404, cb);\n    },\n\n    /**\n     * Catches a timeout (http code 408) and performs a callback.\n     */\n    timeout: function timeout(cb) {\n      return responseChain.error(408, cb);\n    },\n\n    /**\n     * Catches an internal server error (http code 500) and performs a callback.\n     */\n    internalError: function internalError(cb) {\n      return responseChain.error(500, cb);\n    },\n\n    /**\n     * Catches an AbortError and performs a callback.\n     */\n    onAbort: function onAbort(cb) {\n      return responseChain.error(\"AbortError\", cb);\n    }\n  };\n  return resolvers.reduce(function (chain, r) {\n    return r(chain, wretcher);\n  }, responseChain);\n};","map":{"version":3,"sources":["../src/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { Wretcher } from \"./wretcher\"\nimport { mix } from \"./mix\"\nimport conf from \"./config\"\nimport perfs from \"./perfs\"\nimport { middlewareHelper } from \"./middleware\"\n\nexport type WretcherError = Error & { status: number, response: WretcherResponse, text?: string, json?: any }\nexport type WretcherErrorCallback = (error: WretcherError, originalRequest: Wretcher) => any\nexport type WretcherResponse = Response & { [key: string]: any }\nexport type ResponseChain = {\n    // Response types\n    res: <Result = WretcherResponse>(cb?: (type: WretcherResponse) => Result) => Promise<Result>,\n    json: <Result = {[key: string]: any}>(cb?: (type: {[key: string]: any}) => Result) => Promise<Result>,\n    blob: <Result = Blob>(cb?: (type: Blob) => Result) => Promise<Result>,\n    formData: <Result = FormData>(cb?: (type: FormData) => Result) => Promise<Result>,\n    arrayBuffer: <Result = ArrayBuffer>(cb?: (type: ArrayBuffer) => Result) => Promise<Result>,\n    text: <Result = string>(cb?: (type: string) => Result) => Promise<Result>,\n    // Extras\n    perfs: (cb?: (timing: any) => void) => ResponseChain,\n    setTimeout: (time: number, controller?: AbortController) => ResponseChain,\n    controller: () => [any, ResponseChain],\n    // Catchers\n    error: (code: (number | string), cb: WretcherErrorCallback) => ResponseChain,\n    badRequest: (cb: WretcherErrorCallback) => ResponseChain,\n    unauthorized: (cb: WretcherErrorCallback) => ResponseChain,\n    forbidden: (cb: WretcherErrorCallback) => ResponseChain,\n    notFound: (cb: WretcherErrorCallback) => ResponseChain,\n    timeout: (cb: WretcherErrorCallback) => ResponseChain,\n    internalError: (cb: WretcherErrorCallback) => ResponseChain,\n    onAbort: (cb: WretcherErrorCallback) => ResponseChain\n}\n\nexport const resolver = (wretcher: Wretcher) => {\n    const {\n        _url: url,\n        _catchers: _catchers,\n        _resolvers: resolvers,\n        _middlewares: middlewares,\n        _options: opts\n    } = wretcher\n    const catchers = new Map(_catchers)\n    const finalOptions = mix(conf.defaults, opts)\n    const fetchController = conf.polyfill(\"AbortController\", { doThrow: false, instance: true })\n    if(!finalOptions[\"signal\"] && fetchController) {\n        finalOptions[\"signal\"] = fetchController.signal\n    }\n    // Request timeout\n    const timeout = {\n        ref: null,\n        clear() {\n            if(timeout.ref) {\n                clearTimeout(timeout.ref)\n                timeout.ref = null\n            }\n        }\n    }\n    // The generated fetch request\n    const fetchRequest = middlewareHelper(middlewares)(conf.polyfill(\"fetch\"))(url, finalOptions)\n    // Throws on an http error\n    const throwingPromise: Promise<void | WretcherResponse> = fetchRequest.then(response => {\n        timeout.clear()\n        if (!response.ok) {\n            return response[conf.errorType || \"text\"]().then(msg => {\n                // Enhances the error object\n                const err = new Error(msg)\n                err[conf.errorType || \"text\"] = msg\n                err[\"status\"] = response.status\n                err[\"response\"] = response\n                throw err\n            })\n        }\n        return response\n    })\n    // Wraps the Promise in order to dispatch the error to a matching catcher\n    const catchersWrapper = <T>(promise: Promise<T>): Promise<void | T> => {\n        return promise.catch(err => {\n            timeout.clear()\n            if(catchers.has(err.status))\n                return catchers.get(err.status)(err, wretcher)\n            else if(catchers.has(err.name))\n                return catchers.get(err.name)(err, wretcher)\n            else\n                throw err\n        })\n    }\n    // Enforces the proper promise type when a body parsing method is called.\n    type BodyParser = <Type>(funName: string | null) => <Result = void>(cb?: (type: Type) => Result) => Promise<Result>\n    const bodyParser: BodyParser = <T>(funName) => <R>(cb) => funName ?\n        // If a callback is provided, then callback with the body result otherwise return the parsed body itself.\n        catchersWrapper(throwingPromise.then(_ => _ && _[funName]()).then(_ => _ && cb && cb(_) || _)) :\n        // No body parsing method - return the response\n        catchersWrapper(throwingPromise.then(_ => _ && cb && cb(_) || _))\n\n    const responseChain: ResponseChain = {\n        /**\n         * Retrieves the raw result as a promise.\n         */\n        res: bodyParser<WretcherResponse>(null),\n        /**\n         * Retrieves the result as a parsed JSON object.\n         */\n        json: bodyParser<any>(\"json\"),\n        /**\n         * Retrieves the result as a Blob object.\n         */\n        blob: bodyParser<Blob>(\"blob\"),\n        /**\n         * Retrieves the result as a FormData object.\n         */\n        formData: bodyParser<FormData>(\"formData\"),\n        /**\n         * Retrieves the result as an ArrayBuffer object.\n         */\n        arrayBuffer: bodyParser<ArrayBuffer>(\"arrayBuffer\"),\n        /**\n         * Retrieves the result as a string.\n         */\n        text: bodyParser<string>(\"text\"),\n        /**\n         * Performs a callback on the API performance timings of the request.\n         *\n         * Warning: Still experimental on browsers and node.js\n         */\n        perfs: cb => {\n            fetchRequest.then(res => perfs.observe(res.url, cb))\n            return responseChain\n        },\n        /**\n         * Aborts the request after a fixed time.\n         *\n         * @param time Time in milliseconds\n         * @param controller A custom controller\n         */\n        setTimeout: (time, controller = fetchController) => {\n            timeout.clear()\n            timeout.ref = setTimeout(() => controller.abort(), time)\n            return responseChain\n        },\n        /**\n         * Returns the automatically generated AbortController alongside the current wretch response as a pair.\n         */\n        controller: () => [ fetchController, responseChain ],\n        /**\n         * Catches an http response with a specific error code or name and performs a callback.\n         */\n        error(errorId, cb) {\n            catchers.set(errorId, cb)\n            return responseChain\n        },\n        /**\n         * Catches a bad request (http code 400) and performs a callback.\n         */\n        badRequest: cb => responseChain.error(400, cb),\n        /**\n         * Catches an unauthorized request (http code 401) and performs a callback.\n         */\n        unauthorized: cb => responseChain.error(401, cb),\n        /**\n         * Catches a forbidden request (http code 403) and performs a callback.\n         */\n        forbidden: cb => responseChain.error(403, cb),\n        /**\n         * Catches a \"not found\" request (http code 404) and performs a callback.\n         */\n        notFound: cb => responseChain.error(404, cb),\n        /**\n         * Catches a timeout (http code 408) and performs a callback.\n         */\n        timeout: cb => responseChain.error(408, cb),\n        /**\n         * Catches an internal server error (http code 500) and performs a callback.\n         */\n        internalError: cb => responseChain.error(500, cb),\n        /**\n         * Catches an AbortError and performs a callback.\n         */\n        onAbort: cb => responseChain.error(\"AbortError\", cb)\n    }\n\n    return resolvers.reduce((chain, r) => r(chain, wretcher), responseChain) as (ResponseChain & Promise<any>)\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}